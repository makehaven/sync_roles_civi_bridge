<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\user\UserInterface;
use Drupal\civicrm\Civicrm;
use Psr\Log\LoggerInterface;

/**
 * Implements hook_entity_update().
 *
 * Detects user role changes and triggers synchronization with CiviCRM.
 */
function sync_roles_civi_bridge_entity_update(EntityInterface $entity): void {
  if ($entity->getEntityTypeId() === 'user' && $entity instanceof UserInterface) {
    $uid = $entity->id();
    $logger = \Drupal::logger('sync_roles_civi_bridge');
    $logger->info("Entity update hook fired for user ID: @uid", ['@uid' => $uid]);

    // Ensure we have the original roles data to compare against.
    $original_roles_cache = &drupal_static('sync_roles_civi_bridge_original_roles', []);
    $old_roles = NULL;
    if (isset($original_roles_cache[$uid])) {
      $old_roles = $original_roles_cache[$uid];
      unset($original_roles_cache[$uid]);
    }
    elseif (isset($entity->original) && $entity->original instanceof UserInterface) {
      $old_roles = $entity->original->getRoles();
    }

    if ($old_roles !== NULL) {
      $current_roles = $entity->getRoles();

      // Sort arrays for consistent comparison.
      sort($current_roles);
      sort($old_roles);

      if ($current_roles !== $old_roles) {
        $logger->notice("User @uid roles have changed from [@old_roles] to [@current_roles]. Triggering CiviCRM sync.", [
          '@uid' => $uid,
          '@old_roles' => implode(', ', $entity->original->getRoles()), // Log original order
          '@current_roles' => implode(', ', $entity->getRoles()), // Log original order
        ]);
        // Attempt to sync roles to CiviCRM.
        sync_roles_bridge_sync_to_civicrm($entity);
      }
      else {
        $logger->info("User @uid updated but no role changes detected.", ['@uid' => $uid]);
      }
    }
    else {
      // This might happen on first save after creation or if the original entity isn't available.
      // Optionally, you could trigger a sync here too if needed for newly created users,
      // but role changes are the primary trigger based on requirements.
      $logger->info("No original user object found for user ID: @uid. Running sync as precaution.", ['@uid' => $uid]);
      sync_roles_bridge_sync_to_civicrm($entity);
    }
  }
}

/**
 * Implements hook_user_presave().
 */
function sync_roles_civi_bridge_user_presave(UserInterface $account): void {
  $uid = $account->id();
  if (!$uid) {
    return;
  }

  $original_roles_cache = &drupal_static('sync_roles_civi_bridge_original_roles', []);

  if (isset($account->original) && $account->original instanceof UserInterface) {
    $roles = $account->original->getRoles();
  }
  else {
    /** @var \Drupal\user\UserStorageInterface $storage */
    $storage = \Drupal::entityTypeManager()->getStorage('user');
    $existing = $storage->loadUnchanged($uid);
    $roles = $existing instanceof UserInterface ? $existing->getRoles() : $account->getRoles();
  }

  sort($roles);
  $original_roles_cache[$uid] = $roles;
}

/**
 * Implements hook_entity_insert().
 *
 * Ensures newly created users have their roles synchronized once saved.
 */
function sync_roles_civi_bridge_entity_insert(EntityInterface $entity): void {
  if ($entity->getEntityTypeId() === 'user' && $entity instanceof UserInterface) {
    \Drupal::logger('sync_roles_civi_bridge')->info('Entity insert hook fired for user ID: @uid', ['@uid' => $entity->id()]);
    sync_roles_bridge_sync_to_civicrm($entity);
  }
}

/**
 * Helper function to get the CiviCRM contact ID for a Drupal user.
 *
 * Prioritizes UFMatch table lookup via API, falls back to email lookup via API.
 *
 * @param \Drupal\user\UserInterface $account
 * The user account.
 * @param \Psr\Log\LoggerInterface $logger
 * The logger service.
 * @param \Drupal\civicrm\Civicrm $civicrm
 * The CiviCRM initialization service.
 *
 * @return int|null
 * The CiviCRM contact ID if found, or NULL otherwise.
 */
function sync_roles_bridge_get_contact_id(UserInterface $account, LoggerInterface $logger, Civicrm $civicrm): ?int {
  $uid = $account->id();

  // Ensure CiviCRM is usable.
  try {
    $civicrm->initialize();
  }
  catch (\Throwable $e) {
    $logger->error('Failed to initialize CiviCRM for GetContactID: @message', ['@message' => $e->getMessage()]);
    return NULL;
  }

  // --- Attempt 1: UFMatch Lookup (Most Reliable) ---
  try {
    $uf_match_result = civicrm_api3('UFMatch', 'get', [
      'sequential' => 1,
      'uf_id' => $uid,
      'check_permissions' => 0,
    ]);
    if (!empty($uf_match_result['is_error'])) {
      $logger->error('GetContactID: UFMatch lookup failed for user @uid: @message', [
        '@uid' => $uid,
        '@message' => $uf_match_result['error_message'] ?? 'Unknown error',
      ]);
    }
    if (!empty($uf_match_result['values'])) {
      $contact_id = $uf_match_result['values'][0]['contact_id'];
      $logger->info("GetContactID: Found Contact ID @contact_id via UFMatch for User @uid.", [
        '@contact_id' => $contact_id,
        '@uid' => $uid,
      ]);
      return (int) $contact_id;
    }
    $logger->info("GetContactID: No UFMatch record found for User @uid.", ['@uid' => $uid]);
  }
  catch (\Exception $e) {
    $logger->error("GetContactID: CiviCRM API error looking up UFMatch for User @uid: @message", [
      '@uid' => $uid,
      '@message' => $e->getMessage(),
    ]);
    // Continue to fallback methods if UFMatch lookup fails
  }

  // --- Attempt 2: Email Lookup (Fallback) ---
  $email = $account->getEmail();
  if (empty($email)) {
      $logger->warning("GetContactID: User @uid has no email address for fallback lookup.", ['@uid' => $uid]);
      return NULL;
  }

  try {
    $contact_result = civicrm_api3('Contact', 'get', [
      'sequential' => 1,
      'email' => $email,
      'return' => ['id'],
      'options' => ['limit' => 1], // Only need one match
      'check_permissions' => 0,
    ]);
    if (!empty($contact_result['is_error'])) {
      $logger->error('GetContactID: Email lookup failed for user @uid: @message', [
        '@uid' => $uid,
        '@message' => $contact_result['error_message'] ?? 'Unknown error',
      ]);
    }
    if (!empty($contact_result['values'])) {
      $contact_id = $contact_result['values'][0]['id'];
      $logger->notice("GetContactID: Found Contact ID @contact_id via Email fallback for User @uid (@email).", [
         '@contact_id' => $contact_id,
         '@uid' => $uid,
         '@email' => $email,
      ]);
      // OPTIONAL: Create UFMatch record here?
      // try { civicrm_api3('UFMatch', 'create', ['contact_id' => $contact_id, 'uf_id' => $uid]); } catch (\Exception $e) { ... }
      return (int) $contact_id;
    }
    $logger->warning("GetContactID: No Contact found via Email fallback for User @uid (@email).", [
        '@uid' => $uid,
        '@email' => $email,
    ]);
  }
  catch (\Exception $e) {
    $logger->error("GetContactID: CiviCRM API error looking up Contact by Email for User @uid (@email): @message", [
      '@uid' => $uid,
      '@email' => $email,
      '@message' => $e->getMessage(),
    ]);
  }

  // --- Add other fallback methods if needed (e.g., check specific Drupal fields) ---

  $logger->error("GetContactID: Could not find CiviCRM Contact ID for User @uid.", ['@uid' => $uid]);
  return NULL;
}

/**
 * Resolve metadata for a target CiviCRM custom field.
 *
 * Accepts a field identifier in several formats (column name such as
 * "custom_64", the field machine name, or the numeric field ID) and returns
 * the metadata needed for subsequent API calls.
 *
 * @param string $field_identifier
 *   The identifier configured for the custom field.
 * @param \Psr\Log\LoggerInterface $logger
 *   The logger service.
 *
 * @return array|null
 *   The resolved metadata array containing at minimum the keys `id` and
 *   `column_name`. Returns NULL if the field cannot be resolved.
 */
function sync_roles_bridge_resolve_custom_field(string $field_identifier, LoggerInterface $logger): ?array {
  $field_identifier = trim($field_identifier);
  if ($field_identifier === '') {
    $logger->error('MapRoles: Empty custom field identifier provided.');
    return NULL;
  }

  static $cache = [];
  if (array_key_exists($field_identifier, $cache)) {
    return $cache[$field_identifier] ?: NULL;
  }

  $strategies = [];
  if (ctype_digit($field_identifier)) {
    $strategies[] = ['id', (int) $field_identifier];
  }
  if (preg_match('/^custom_(\d+)$/i', $field_identifier, $matches)) {
    $strategies[] = ['id', (int) $matches[1]];
    $strategies[] = ['column_name', $field_identifier];
  }
  // Machine name lookup is the most common alternative.
  $strategies[] = ['name', $field_identifier];

  $metadata = NULL;
  $attempts = [];

  foreach ($strategies as [$field, $value]) {
    $attempts[] = sprintf('%s=%s', $field, is_scalar($value) ? (string) $value : '[complex]');

    try {
      $result = civicrm_api3('CustomField', 'get', [
        'sequential' => 1,
        'return' => ['id', 'name', 'label', 'column_name', 'option_group_id', 'html_type', 'data_type', 'is_multi_select'],
        'options' => ['limit' => 1],
        'check_permissions' => 0,
        $field => $value,
      ]);
      if (!empty($result['is_error'])) {
        $logger->error('MapRoles: CustomField lookup error for @identifier via @field: @message', [
          '@identifier' => $field_identifier,
          '@field' => $field,
          '@message' => $result['error_message'] ?? 'Unknown error',
        ]);
        continue;
      }
    }
    catch (\Exception $e) {
      $logger->error('MapRoles: Failed to look up custom field @identifier via @field: @message', [
        '@identifier' => $field_identifier,
        '@field' => $field,
        '@message' => $e->getMessage(),
      ]);
      continue;
    }

    if (!empty($result['values'][0])) {
      $metadata = $result['values'][0];
      break;
    }
  }

  if (!$metadata) {
    $logger->error('MapRoles: Unable to resolve CiviCRM custom field "@identifier". Attempted lookups: @attempts.', [
      '@identifier' => $field_identifier,
      '@attempts' => implode(', ', $attempts),
    ]);
    $cache[$field_identifier] = FALSE;
    return NULL;
  }

  // Cache positive result for subsequent invocations.
  // Ensure downstream consumers know the canonical API field name (custom_N).
  if (!isset($metadata['api_field_name'])) {
    $metadata['api_field_name'] = 'custom_' . ($metadata['id'] ?? '');
  }

  $cache[$field_identifier] = $metadata;
  return $metadata;
}

/**
 * Builds a list of normalized keys for fuzzy-matching names/labels.
 *
 * @param string $value
 *   The value to normalize.
 *
 * @return array
 *   A list of normalized variants suitable for comparisons.
 */
function sync_roles_bridge_generate_match_variants(string $value): array {
  $value = trim($value);
  if ($value === '') {
    return [];
  }

  $lower = strtolower($value);
  $variants = [
    $lower,
    str_replace([' ', '-'], '_', $lower),
    str_replace(['_', '-'], ' ', $lower),
    str_replace('_', '-', $lower),
    str_replace([' ', '_', '-'], '', $lower),
  ];

  $unique = [];
  foreach ($variants as $variant) {
    $variant = trim($variant);
    if ($variant === '') {
      continue;
    }
    $unique[$variant] = TRUE;
  }

  return array_keys($unique);
}

/**
 * Maps Drupal role names to values belonging to a CiviCRM Option Group.
 *
 * @param array $role_names
 *   Array of Drupal role machine names.
 * @param int $option_group_id
 *   The option group identifier attached to the custom field.
 * @param \Psr\Log\LoggerInterface $logger
 *   The logger service.
 *
 * @return array|null
 *   An array of CiviCRM option values corresponding to the roles, NULL on
 *   failure.
 */
function sync_roles_bridge_map_roles_to_option_values(array $role_names, int $option_group_id, LoggerInterface $logger): ?array {
  if (empty($role_names)) {
    return [];
  }

  if ($option_group_id <= 0) {
    $logger->error('MapRoles: Invalid option group ID (@id) provided.', ['@id' => $option_group_id]);
    return NULL;
  }

  static $option_group_cache = [];

  if (!isset($option_group_cache[$option_group_id])) {
    try {
      $option_values_result = civicrm_api3('OptionValue', 'get', [
        'sequential' => 1,
        'option_group_id' => $option_group_id,
        'is_active' => 1,
        'return' => ['label', 'name', 'value'],
        'options' => ['limit' => 0],
        'check_permissions' => 0,
      ]);
      if (!empty($option_values_result['is_error'])) {
        $logger->error('MapRoles: OptionValue lookup error for option group @group_id: @message', [
          '@group_id' => $option_group_id,
          '@message' => $option_values_result['error_message'] ?? 'Unknown error',
        ]);
        return NULL;
      }
    }
    catch (\Exception $e) {
      $logger->error('MapRoles: Failed to load option values for option group @group_id: @message', [
        '@group_id' => $option_group_id,
        '@message' => $e->getMessage(),
      ]);
      return NULL;
    }

    if (empty($option_values_result['values'])) {
      $logger->warning('MapRoles: No option values found for option group @group_id.', ['@group_id' => $option_group_id]);
      $option_group_cache[$option_group_id] = ['map' => []];
    }
    else {
      $key_map = [];
      foreach ($option_values_result['values'] as $option) {
        $value = (string) $option['value'];
        $candidates = [];
        foreach (['label', 'name', 'value'] as $property) {
          if (!empty($option[$property])) {
            $candidates[] = strtolower((string) $option[$property]);
          }
        }
        foreach ($candidates as $candidate) {
          foreach (sync_roles_bridge_generate_match_variants($candidate) as $variant) {
            $key_map[$variant] = $value;
          }
        }
      }
      $option_group_cache[$option_group_id] = ['map' => $key_map];
    }
  }

  $key_map = $option_group_cache[$option_group_id]['map'];

  if (!$key_map) {
    return [];
  }

  $mapped = [];
  $unmapped = [];
  foreach ($role_names as $role_name) {
    $matched = FALSE;
    foreach (sync_roles_bridge_generate_match_variants($role_name) as $variant) {
      if (isset($key_map[$variant])) {
        $mapped[$key_map[$variant]] = TRUE;
        $matched = TRUE;
        break;
      }
    }
    if (!$matched) {
      $unmapped[] = $role_name;
    }
  }

  if (!empty($unmapped)) {
    $logger->warning('MapRoles: Unmapped Drupal roles for option group @group_id: [@roles].', [
      '@group_id' => $option_group_id,
      '@roles' => implode(', ', $unmapped),
    ]);
  }

  return array_keys($mapped);
}

/**
 * Sync filtered Drupal roles to a configured CiviCRM custom field.
 *
 * Fetches configuration, finds contact ID, maps roles to CiviCRM Option Value IDs,
 * and calls the CiviCRM API.
 *
 * @param \Drupal\user\UserInterface $account
 * The user account being synced.
 */
function sync_roles_bridge_sync_to_civicrm(UserInterface $account): void {
  // Get services
  $logger = \Drupal::logger('sync_roles_civi_bridge');
  /** @var \Drupal\Core\Config\ConfigFactoryInterface $config_factory */
  $config_factory = \Drupal::service('config.factory');
  /** @var \Drupal\civicrm\Civicrm $civicrm */
  $civicrm = \Drupal::service('civicrm');

  // --- Initialization and Configuration ---
  try {
    $civicrm->initialize();
  }
  catch (\Throwable $e) {
    $logger->error('SyncToCivi: Failed to initialize CiviCRM: @message', ['@message' => $e->getMessage()]);
    return;
  }

  $config = $config_factory->get('sync_roles_civi_bridge.settings');
  $custom_field_identifier = $config->get('custom_field');

  if (empty($custom_field_identifier)) {
    $custom_field_identifier = 'custom_64';
    $logger->warning('SyncToCivi: Custom field setting is empty; falling back to default @default.', ['@default' => $custom_field_identifier]);
  }
  else {
    $logger->info('SyncToCivi: Using configured CiviCRM custom field identifier "@identifier".', ['@identifier' => $custom_field_identifier]);
  }

  $field_metadata = sync_roles_bridge_resolve_custom_field($custom_field_identifier, $logger);
  if (!$field_metadata) {
    $logger->error('SyncToCivi: Failed to resolve metadata for custom field "@identifier". Aborting sync.', ['@identifier' => $custom_field_identifier]);
    return;
  }

  $column_name = $field_metadata['column_name'] ?? $custom_field_identifier;
  $api_field_name = $field_metadata['api_field_name'] ?? $custom_field_identifier;
  $option_group_id = !empty($field_metadata['option_group_id']) ? (int) $field_metadata['option_group_id'] : NULL;
  $html_type = $field_metadata['html_type'] ?? NULL;
  $is_multi_select = !empty($field_metadata['is_multi_select']) || in_array($html_type, ['CheckBox', 'Multi-Select', 'AdvMulti-Select'], TRUE);

  $logger->info('SyncToCivi: Resolved custom field identifier "@identifier" to column "@column" (Option Group: @group).', [
    '@identifier' => $custom_field_identifier,
    '@column' => $api_field_name,
    '@group' => $option_group_id ?? 'n/a',
  ]);

  // --- Get Data ---
  $uid = $account->id();
  $roles = $account->getRoles();

  // Filter out roles not intended for CiviCRM (e.g., 'authenticated').
  // Consider making the list of filtered roles configurable later.
  $filtered_roles = array_filter($roles, fn($role) => $role !== 'authenticated');
  $logger->info("SyncToCivi: Filtered Drupal roles for User @uid: [@filtered_roles]", [
      '@uid' => $uid,
      '@filtered_roles' => implode(', ', $filtered_roles),
  ]);

  $contactId = sync_roles_bridge_get_contact_id($account, $logger, $civicrm);
  if (!$contactId) {
    $logger->error("SyncToCivi: Could not find Contact ID for User @uid. Aborting sync.", ['@uid' => $uid]);
    return;
  }
  $logger->info("SyncToCivi: Found Contact ID @contact_id for User @uid.", [
      '@contact_id' => $contactId,
      '@uid' => $uid,
  ]);


  // --- CRITICAL STEP: Prepare the value that will be written to CiviCRM ---
  if ($option_group_id) {
    $civi_role_values = sync_roles_bridge_map_roles_to_option_values($filtered_roles, $option_group_id, $logger);

    if ($civi_role_values === NULL) {
      $logger->error('SyncToCivi: Failed to map Drupal roles to CiviCRM Option Values for User @uid. Aborting API call.', ['@uid' => $uid]);
      return;
    }

    if ($is_multi_select) {
      $civi_field_value_for_api = [];
      foreach ($civi_role_values as $value) {
        $civi_field_value_for_api[(string) $value] = (string) $value;
      }
    }
    else {
      $civi_field_value_for_api = !empty($civi_role_values) ? (string) reset($civi_role_values) : '';
    }
  }
  else {
    // Fall back to storing the raw role names as a comma separated string.
    $logger->notice('SyncToCivi: Custom field @column is not option-based; storing raw Drupal roles.', ['@column' => $api_field_name]);
    $civi_field_value_for_api = !empty($filtered_roles) ? implode(',', $filtered_roles) : '';
  }


  // --- Prepare and Execute API Call ---
  $params = [
    'id' => $contactId, // Use 'id' instead of 'contact_id' for Contact.create with existing ID
    $api_field_name => $civi_field_value_for_api,
    'check_permissions' => 0,
  ];

  $log_params = $params; // Copy params for logging
  // Avoid logging potentially sensitive data if custom field could hold it
  // unset($log_params[$api_field_name]);
  // $log_params[$api_field_name] = is_array($civi_field_value_for_api) ? implode(',', $civi_field_value_for_api) : $civi_field_value_for_api; // Log formatted value
  $logger->notice("SyncToCivi: PARAMS Sent to API for User @uid (Contact @contact_id): @params", [
      '@uid' => $uid,
      '@contact_id' => $contactId,
      '@params' => print_r($log_params, TRUE), // Use print_r for array visibility in logs
  ]);


  try {
    // Use Contact 'create' with an ID to perform an update.
    $result = civicrm_api3('Contact', 'create', $params);

    if (!empty($result['is_error'])) {
        // API call returned an error structure without throwing exception
        $logger->error("SyncToCivi: CiviCRM API returned an error for User @uid (Contact @contact_id): @error_message. PARAMS: @params", [
           '@uid' => $uid,
           '@contact_id' => $contactId,
           '@error_message' => $result['error_message'] ?? 'Unknown API error structure',
           '@params' => print_r($params, TRUE),
        ]);
    } else {
        $logger->notice("SyncToCivi: CiviCRM Contact @contact_id updated successfully for User @uid.", [
           '@contact_id' => $contactId,
           '@uid' => $uid,
        ]);
    }
  }
  catch (\Exception $e) {
    // Catch exceptions for robust error logging
    $logger->error("SyncToCivi: CiviCRM API EXCEPTION for User @uid (Contact @contact_id): @message. PARAMS: @params", [
      '@uid' => $uid,
      '@contact_id' => $contactId,
      '@message' => $e->getMessage(),
      '@params' => print_r($params, TRUE),
    ]);
  }

  $logger->info("SyncToCivi: FINISHED sync process for User ID: @uid", ['@uid' => $uid]);
}

/**
 * Batch API process callback.
 *
 * This function is called by the batch system for each user.
 *
 * @param int $uid
 * The user ID to process.
 * @param array $context
 * The batch context array.
 */
function sync_roles_bridge_batch_process($uid, &$context) {
  $logger = \Drupal::logger('sync_roles_civi_bridge');
  /** @var \Drupal\user\UserInterface|null $user */
  $user = \Drupal\user\Entity\User::load($uid);

  if ($user) {
    // Call the existing sync function from this module.
    sync_roles_bridge_sync_to_civicrm($user);
    $context['results']['processed'][] = $uid;
  }
  else {
    $logger->warning('Batch Process: Could not load user with UID @uid.', ['@uid' => $uid]);
    $context['results']['errors'][] = $uid;
  }

  // Set a message for the batch progress indicator.
  $context['message'] = t('Processing user ID @uid...', ['@uid' => $uid]);
}

/**
 * Batch API finished callback.
 *
 * This function is called when the batch process is complete.
 *
 * @param bool $success
 * Indicates whether the batch operation was successful.
 * @param array $results
 * The results of the batch operation.
 * @param array $operations
 * The operations that were performed.
 */
function sync_roles_bridge_batch_finished($success, $results, $operations) {
  $messenger = \Drupal::messenger();
  if ($success) {
    $processed_count = isset($results['processed']) ? count($results['processed']) : 0;
    $error_count = isset($results['errors']) ? count($results['errors']) : 0;
    $messenger->addStatus(t('@count users were processed successfully.', ['@count' => $processed_count]));
    if ($error_count > 0) {
      $messenger->addWarning(t('@count users could not be processed. Check logs for details.', ['@count' => $error_count]));
    }
  }
  else {
    // An error occurred.
    $messenger->addError(t('An error occurred during the batch process. Please check the logs.'));
  }
}
